"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Auth = void 0;
const core_1 = require("@oclif/core");
const commonFlags = require("../common/flags");
const path = require("path");
const fs = require("fs");
const YAML = require("js-yaml");
const definition_1 = require("../common/definition");
const config_1 = require("../common/config");
const security_1 = require("../common/security");
class Auth extends core_1.Command {
    async run() {
        const { args, flags } = await this.parse(Auth);
        const { dereference, validate, bundle, header, inject, token, apikey, username, password } = flags;
        const definition = (0, definition_1.resolveDefinition)(args.definition);
        if (!definition) {
            this.error('Please load a definition file', { exit: 1 });
        }
        let document;
        try {
            document = await (0, definition_1.parseDefinition)({
                definition,
                dereference,
                bundle,
                validate,
                inject,
                strip: flags.strip,
                servers: flags.server,
                header,
            });
        }
        catch (err) {
            this.error(err, { exit: 1 });
        }
        // get config file
        const configFile = (0, config_1.resolveConfigFile)();
        const writeTo = path.resolve(configFile || `./${config_1.CONFIG_FILENAME}`);
        // write to config file
        const oldConfig = configFile ? YAML.load(fs.readFileSync(configFile).toString()) : {};
        const newConfig = {
            ...oldConfig,
            definition,
            security: { ...oldConfig.security },
        };
        // choose security schemes
        const securityScheme = await (0, security_1.getActiveSecuritySchemes)({
            document,
            security: flags.security,
            header,
            token,
            apikey,
            username,
            password,
        });
        for (const schemeName of securityScheme) {
            const schemeDefinition = document.components.securitySchemes[schemeName];
            if (schemeDefinition) {
                newConfig.security[schemeName] = await (0, security_1.createSecurityRequestConfigForScheme)({
                    schemeName,
                    schemeDefinition,
                    token,
                    apikey,
                    username,
                    password,
                });
            }
        }
        // write as YAML
        fs.writeFileSync(writeTo, YAML.dump(newConfig));
        this.log(`Wrote auth config to ${writeTo}. You can now use openapi call with the following auth configs:`);
        this.log(`${Object.keys(newConfig.security)
            .map((key) => `- ${key}`)
            .join('\n')}`);
    }
}
exports.Auth = Auth;
Auth.description = 'Authenticate with apis (writes to .openapiconfig)';
Auth.examples = [
    `$ openapi auth`,
    '$ openapi auth --token eyJh...',
    '$ openapi auth --security ApiKeyAuth --apikey secret123',
    '$ openapi auth --security BasicAuth --username admin --password password',
];
Auth.flags = {
    ...commonFlags.help(),
    ...commonFlags.validate(),
    ...commonFlags.parseOpts(),
    ...commonFlags.securityOpts(),
    ...commonFlags.inject(),
};
Auth.args = {
    definition: core_1.Args.string({
        description: 'input definition file'
    })
};
