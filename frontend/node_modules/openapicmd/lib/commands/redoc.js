"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Redoc = void 0;
const core_1 = require("@oclif/core");
const url_1 = require("url");
const fs = require("fs");
const path = require("path");
const proxy = require("koa-proxy");
const mount = require("koa-mount");
const commonFlags = require("../common/flags");
const definition_1 = require("../common/definition");
const koa_1 = require("../common/koa");
const utils_1 = require("../common/utils");
const redoc_1 = require("../common/redoc");
class Redoc extends core_1.Command {
    async run() {
        var _a;
        const { args, flags } = await this.parse(Redoc);
        const { port, logger, bundle, header, root } = flags;
        const definition = (0, definition_1.resolveDefinition)(args.definition);
        const app = (0, koa_1.createServer)({ logger });
        let proxyPath;
        let documentPath;
        let document;
        const openApiFile = 'openapi.json';
        if (definition) {
            if (definition.match('://') && !flags.server && !flags.proxy) {
                // use remote definition
                documentPath = definition;
            }
            else {
                // parse definition
                document = await (0, definition_1.parseDefinition)({
                    definition,
                    servers: flags.server,
                    inject: flags.inject,
                    excludeExt: flags === null || flags === void 0 ? void 0 : flags['exclude-ext'],
                    removeUnreferenced: flags === null || flags === void 0 ? void 0 : flags['remove-unreferenced'],
                    strip: flags.strip,
                    header,
                    root,
                });
                documentPath = `./${openApiFile}`;
            }
        }
        const redocOpts = {
            specUrl: documentPath,
            title: (_a = document === null || document === void 0 ? void 0 : document.info) === null || _a === void 0 ? void 0 : _a.title,
        };
        if (bundle) {
            // bundle files to directory
            const bundleDir = path.resolve(bundle);
            // create a directory if one does not exist
            if (!fs.existsSync(bundleDir)) {
                fs.mkdirSync(bundleDir);
            }
            // copy openapi definition file
            if (document) {
                const openApiPath = path.join(bundleDir, openApiFile);
                fs.writeFileSync(openApiPath, JSON.stringify(document));
                this.log(`${openApiPath}`);
            }
            // copy redoc index.html file
            const redocPath = path.join(bundleDir, 'index.html');
            const redocHtml = (0, redoc_1.getRedocIndexHTML)(redocOpts);
            fs.writeFileSync(redocPath, redocHtml);
            this.log(path.join(redocPath));
        }
        else {
            if (flags.proxy) {
                // set up a proxy for the api
                let serverURL = null;
                if (document.servers && document.servers[0]) {
                    serverURL = document.servers[0].url;
                }
                if (flags.server && typeof flags.server === 'object') {
                    serverURL = flags.server[0];
                }
                if (flags.server && typeof flags.server === 'string') {
                    serverURL = flags.server;
                }
                if (!serverURL) {
                    this.error('Unable to find server URL from definition, please provide a --server parameter');
                }
                const apiUrl = new url_1.URL(serverURL);
                const proxyOpts = {
                    host: `${apiUrl.protocol}//${apiUrl.host}`,
                    map: (path) => {
                        if (flags.root) {
                            return `${flags.root}${path}`;
                        }
                        if (apiUrl.pathname === '/') {
                            return path;
                        }
                        return `${apiUrl.pathname}${path}`;
                    },
                    jar: flags.withcredentials,
                };
                proxyPath = '/proxy';
                app.use(mount(proxyPath, (ctx, next) => {
                    ctx.request.header = {
                        ...ctx.request.header,
                        ...(0, utils_1.parseHeaderFlag)(header),
                    };
                    return proxy(proxyOpts)(ctx, next);
                }));
                document.servers = [{ url: proxyPath }, ...document.servers];
            }
            if (document) {
                // serve the openapi file
                app.use(mount(`/${openApiFile}`, (ctx) => {
                    ctx.body = JSON.stringify(document);
                }));
            }
            // serve swagger ui
            app.use(mount('/', (0, redoc_1.serveRedoc)(redocOpts)));
            // start server
            const { port: portRunning } = await (0, koa_1.startServer)({ app, port });
            this.log(`Redoc running at http://localhost:${portRunning}`);
            if (document) {
                this.log(`OpenAPI definition at http://localhost:${portRunning}/${openApiFile}`);
            }
            if (proxyPath) {
                this.log(`Proxy running at http://localhost:${portRunning}${proxyPath}`);
            }
            this.log();
        }
    }
}
exports.Redoc = Redoc;
Redoc.description = 'Start or bundle a ReDoc instance';
Redoc.examples = [
    '$ openapi redoc',
    '$ openapi redoc ./openapi.yml',
    '$ openapi redoc ./openapi.yml --bundle outDir',
];
Redoc.flags = {
    ...commonFlags.help(),
    ...commonFlags.serverOpts(),
    ...commonFlags.servers(),
    ...commonFlags.inject(),
    ...commonFlags.excludeExt(),
    ...commonFlags.strip(),
    ...commonFlags.header(),
    ...commonFlags.apiRoot(),
    bundle: core_1.Flags.string({
        char: 'B',
        description: 'bundle a static site to directory',
        helpValue: 'outDir',
    }),
};
Redoc.args = {
    definition: core_1.Args.string({
        description: 'input definition file'
    })
};
