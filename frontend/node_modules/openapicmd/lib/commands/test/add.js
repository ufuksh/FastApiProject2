"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestAdd = void 0;
const core_1 = require("@oclif/core");
const config_1 = require("../../common/config");
const mock_json_schema_1 = require("mock-json-schema");
const YAML = require("js-yaml");
const path = require("path");
const fs = require("fs");
const openapi_client_axios_1 = require("openapi-client-axios");
const definition_1 = require("../../common/definition");
const commonFlags = require("../../common/flags");
const debug_1 = require("debug");
const utils_1 = require("../../common/utils");
const security_1 = require("../../common/security");
const tests_1 = require("../../tests/tests");
const prompt_1 = require("../../common/prompt");
const context_1 = require("../../common/context");
const _ = require("lodash");
const debug = (0, debug_1.default)('cmd');
class TestAdd extends core_1.Command {
    async run() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const { args, flags } = await this.parse(TestAdd);
        const { dereference, validate, bundle, header } = flags;
        const definition = (0, definition_1.resolveDefinition)(args.definition);
        if (!definition) {
            this.error('Please load a definition file', { exit: 1 });
        }
        if (flags.auto) {
            // dont prompt in auto mode
            flags.interactive = false;
        }
        // store flags in context
        (0, context_1.setContext)((ctx) => ({ ...ctx, flags }));
        let document;
        try {
            document = await (0, definition_1.parseDefinition)({
                definition,
                dereference,
                bundle,
                validate,
                servers: flags.server,
                inject: flags.inject,
                strip: flags.strip,
                header,
                induceServers: true,
            });
        }
        catch (err) {
            this.error(err, { exit: 1 });
        }
        const api = new openapi_client_axios_1.default({ definition: document });
        await api.init();
        // select operation
        let operationId = flags.operation;
        if (!flags.auto) {
            if (!operationId) {
                const res = await (0, prompt_1.maybePrompt)([
                    {
                        name: 'operation',
                        message: 'select operation',
                        type: 'list',
                        choices: api.getOperations().map((op) => {
                            const { operationId: id, summary, description, method, path } = op;
                            let name = `${method.toUpperCase()} ${path}`;
                            if (summary) {
                                name = `${name} - ${summary}`;
                            }
                            else if (description) {
                                name = `${name} - ${description}`;
                            }
                            if (id) {
                                name = `${name} (${id})`;
                            }
                            return { name, value: id };
                        }),
                    },
                ]);
                operationId = res.operation;
            }
            if (!operationId) {
                this.error(`no operationId passed, please specify --operation`, { exit: 1 });
            }
            const operation = api.getOperation(operationId);
            if (!operation) {
                this.error(`operationId ${operationId} not found`, { exit: 1 });
            }
        }
        // give test name
        let testName = flags.name;
        if (!testName) {
            testName = (await (0, prompt_1.maybePrompt)({
                name: 'testName',
                message: 'test name',
                default: 'call operation'
            })).testName;
        }
        // configure checks
        let checks = flags.checks;
        if (!(checks === null || checks === void 0 ? void 0 : checks.length) && flags.auto) {
            // default checks only
            checks = ['Success2XX', 'ValidResponseBody'];
        }
        if (!(checks === null || checks === void 0 ? void 0 : checks.length) && !flags.auto) {
            checks = await (0, prompt_1.maybePrompt)({
                name: 'checks',
                message: 'checks to include in test',
                type: 'checkbox',
                choices: [{
                        name: '2XX response',
                        value: 'Success2XX',
                        checked: true,
                    },
                    {
                        name: 'Validate Response Body',
                        value: 'ValidResponseBody',
                        checked: true,
                    }]
            }).then((res) => res.checks);
        }
        const operationsToAddTests = flags.auto ? api.getOperations() : [api.getOperation(operationId)];
        const testsToAdd = {};
        for (const operation of operationsToAddTests) {
            // fill params
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const params = {};
            for (const param of flags.param || []) {
                const [key, value] = param.split('=');
                params[key.trim()] = value;
            }
            for (const p of operation.parameters || []) {
                const param = p;
                const { name, required, example, schema } = param;
                if (!params[name] && required) {
                    const mockedValue = schema ? (0, mock_json_schema_1.mock)(schema) : undefined;
                    const value = await (0, prompt_1.maybeSimplePrompt)(name, { required, default: example !== null && example !== void 0 ? example : mockedValue });
                    params[name] = value;
                }
            }
            // handle request body
            let data = flags.data;
            if (!data &&
                operation.requestBody &&
                'content' in operation.requestBody &&
                (await (0, prompt_1.maybePrompt)({ type: 'confirm', default: true, name: 'yes', message: 'add request body?' })).yes) {
                const contentType = Object.keys(operation.requestBody.content)[0];
                let defaultValue = (_b = (_a = operation.requestBody.content) === null || _a === void 0 ? void 0 : _a[contentType]) === null || _b === void 0 ? void 0 : _b.example;
                if (!defaultValue && ((_d = (_c = operation.requestBody.content) === null || _c === void 0 ? void 0 : _c[contentType]) === null || _d === void 0 ? void 0 : _d.schema)) {
                    defaultValue = JSON.stringify((0, mock_json_schema_1.mock)((_f = (_e = operation.requestBody.content) === null || _e === void 0 ? void 0 : _e[contentType]) === null || _f === void 0 ? void 0 : _f.schema), null, 2);
                }
                if (!defaultValue && contentType === 'application/json') {
                    defaultValue = '{}';
                }
                data = (await (0, prompt_1.maybePrompt)({
                    type: 'editor',
                    message: contentType || '',
                    name: 'requestBody',
                    default: defaultValue,
                    validate: (value) => {
                        if (contentType === 'application/json' && !(0, utils_1.isValidJson)(value)) {
                            return 'invalid json';
                        }
                        return true;
                    },
                })).requestBody;
            }
            const securityRequestConfig = await (0, security_1.createSecurityRequestConfig)({
                document,
                operation,
                security: flags.security,
                header: flags.header,
                apikey: flags.apikey,
                token: flags.token,
                username: flags.username,
                password: flags.password,
            });
            debug('securityRequestConfig %o', securityRequestConfig);
            const config = {};
            // add cookies
            const cookies = {
                ...securityRequestConfig.cookie,
            };
            const cookieHeader = Object.keys(cookies)
                .map((key) => `${key}=${cookies[key]}`)
                .join('; ');
            // add request headers
            config.headers = {
                ...securityRequestConfig.header,
                ...(0, utils_1.parseHeaderFlag)(header),
                ...(Boolean(cookieHeader) && { cookie: cookieHeader }),
            };
            // add query params
            if (Object.keys({ ...securityRequestConfig.query }).length) {
                config.params = securityRequestConfig.query;
            }
            // add basic auth
            if (Object.keys({ ...securityRequestConfig.auth }).length) {
                config.auth = securityRequestConfig.auth;
            }
            // set content type
            if (!config.headers['Content-Type'] && !config.headers['content-type']) {
                const operationRequestContentType = Object.keys((_h = (_g = operation.requestBody) === null || _g === void 0 ? void 0 : _g['content']) !== null && _h !== void 0 ? _h : {})[0];
                const defaultContentType = (0, utils_1.isValidJson)(data) ? 'application/json' : undefined;
                config.headers['Content-Type'] = operationRequestContentType !== null && operationRequestContentType !== void 0 ? operationRequestContentType : defaultContentType;
            }
            testsToAdd[operation.operationId] = {
                ...testsToAdd[operation.operationId],
                [testName]: {
                    checks,
                    request: {
                        params,
                        data,
                        config,
                    },
                },
            };
            this.log(`Added ${checks.length === 1 ? `test` : `${checks.length} tests`} for ${operation.operationId} "${testName}"`);
        }
        const configFile = (0, config_1.resolveConfigFile)();
        // write to config file
        const oldConfig = configFile ? YAML.load(fs.readFileSync(configFile).toString()) : {};
        const newConfig = {
            ...oldConfig,
            definition,
            tests: {
                ...oldConfig.tests,
                ..._.mapValues(testsToAdd, (tests, operationId) => {
                    var _a;
                    return ({
                        ...(_a = oldConfig.tests) === null || _a === void 0 ? void 0 : _a[operationId],
                        ...tests,
                    });
                }),
            }
        };
        // default to current directory
        const writeTo = path.resolve(configFile || `./${config_1.CONFIG_FILENAME}`);
        // write as YAML
        fs.writeFileSync(writeTo, YAML.dump(newConfig, { noRefs: true }));
        this.log(`Wrote to ${writeTo}`);
        this.log(`You can now run tests with \`${this.config.bin} test\``);
    }
}
exports.TestAdd = TestAdd;
TestAdd.description = 'Add automated tests for API operations';
TestAdd.examples = [
    `$ openapi test add`,
    `$ openapi test add -o getPet --checks all`,
];
TestAdd.flags = {
    ...commonFlags.help(),
    ...commonFlags.parseOpts(),
    ...commonFlags.apiRoot(),
    auto: core_1.Flags.boolean({ description: 'auto generate tests for all operations', default: false }),
    operation: core_1.Flags.string({ char: 'o', description: 'operationId', helpValue: 'operationId' }),
    name: core_1.Flags.string({ char: 'n', description: 'test name', helpValue: 'my test' }),
    checks: core_1.Flags.string({ char: 'c', description: 'checks to include in test', helpValue: '2XXStatus', multiple: true, options: tests_1.TEST_CHECKS }),
    param: core_1.Flags.string({ char: 'p', description: 'parameter', helpValue: 'key=value', multiple: true }),
    data: core_1.Flags.string({ char: 'd', description: 'request body' }),
    verbose: core_1.Flags.boolean({
        char: 'v',
        description: 'verbose mode',
        default: false,
    }),
    ...commonFlags.interactive(),
    ...commonFlags.securityOpts(),
};
TestAdd.args = {
    definition: core_1.Args.string({
        description: 'input definition file'
    })
};
