"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Typegen = void 0;
const core_1 = require("@oclif/core");
const core_2 = require("@oclif/core");
const definition_1 = require("../common/definition");
const commonFlags = require("../common/flags");
const typegen_1 = require("../typegen/typegen");
class Typegen extends core_2.Command {
    async run() {
        const { args, flags } = await this.parse(Typegen);
        const { dereference, validate, bundle, header, root } = flags;
        const definition = (0, definition_1.resolveDefinition)(args.definition);
        if (!definition) {
            this.error('Please load a definition file', { exit: 1 });
        }
        let document;
        try {
            document = await (0, definition_1.parseDefinition)({
                definition,
                dereference,
                bundle,
                validate,
                inject: flags.inject,
                excludeExt: flags === null || flags === void 0 ? void 0 : flags['exclude-ext'],
                removeUnreferenced: flags === null || flags === void 0 ? void 0 : flags['remove-unreferenced'],
                strip: flags.strip,
                servers: flags.server,
                header,
                root,
            });
        }
        catch (err) {
            this.error(err, { exit: 1 });
        }
        const withTypeAliases = flags['type-aliases'];
        const mode = this.mode(flags.client, flags.backend);
        await this.outputBanner(flags.banner);
        await this.outputTypes(document, mode, withTypeAliases);
    }
    mode(client, backend) {
        if (client && backend) {
            return 'both';
        }
        else if (backend) {
            return 'backend';
        }
        // default to client
        return 'client';
    }
    async outputBanner(banner) {
        if (banner) {
            this.log(banner + '\n');
        }
    }
    async outputTypes(document, mode, withTypeAliases) {
        const { clientImports, backendImports, schemaTypes, clientOperationTypes, backendOperationTypes, rootLevelAliases } = await (0, typegen_1.generateTypesForDocument)(document, { transformOperationName: (name) => name });
        if (['both', 'client'].includes(mode)) {
            this.log(clientImports);
        }
        if (['both', 'backend'].includes(mode)) {
            this.log(backendImports);
        }
        this.log(`\n${schemaTypes}`);
        if (['both', 'client'].includes(mode)) {
            this.log(clientOperationTypes);
        }
        if (['both', 'backend'].includes(mode)) {
            this.log(backendOperationTypes);
        }
        if (withTypeAliases && rootLevelAliases) {
            this.log(`\n${rootLevelAliases}`);
        }
    }
}
exports.Typegen = Typegen;
Typegen.description = 'Generate types from openapi definition';
Typegen.examples = [
    `$ openapi typegen ./openapi.yml > openapi.d.ts`,
];
Typegen.flags = {
    ...commonFlags.help(),
    ...commonFlags.parseOpts(),
    banner: core_1.Flags.string({
        char: 'b',
        description: 'include a banner comment at the top of the generated file'
    }),
    client: core_1.Flags.boolean({
        description: 'Generate types for openapi-client-axios (default)',
        default: false,
    }),
    backend: core_1.Flags.boolean({
        description: 'Generate types for openapi-backend',
        default: false,
    }),
    ['type-aliases']: core_1.Flags.boolean({
        char: 'A',
        description: 'Generate module level type aliases for schema components defined in spec',
        default: true,
        allowNo: true,
    }),
};
Typegen.args = {
    definition: core_2.Args.string({
        description: 'input definition file'
    })
};
