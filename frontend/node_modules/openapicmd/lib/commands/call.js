"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Call = void 0;
const core_1 = require("@oclif/core");
const mock_json_schema_1 = require("mock-json-schema");
const chalk = require("chalk");
const _ = require("lodash");
const openapi_client_axios_1 = require("openapi-client-axios");
const definition_1 = require("../common/definition");
const commonFlags = require("../common/flags");
const debug_1 = require("debug");
const utils_1 = require("../common/utils");
const security_1 = require("../common/security");
const context_1 = require("../common/context");
const prompt_1 = require("../common/prompt");
const debug = (0, debug_1.default)('cmd');
class Call extends core_1.Command {
    async run() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const { args, flags } = await this.parse(Call);
        const { dereference, validate, bundle, header } = flags;
        // store flags in context
        (0, context_1.setContext)((ctx) => ({ ...ctx, flags }));
        const definition = (0, definition_1.resolveDefinition)(args.definition);
        if (!definition) {
            this.error('Please load a definition file', { exit: 1 });
        }
        let document;
        try {
            document = await (0, definition_1.parseDefinition)({
                definition,
                dereference,
                bundle,
                validate,
                servers: flags.server,
                inject: flags.inject,
                strip: flags.strip,
                excludeExt: flags === null || flags === void 0 ? void 0 : flags['exclude-ext'],
                removeUnreferenced: flags === null || flags === void 0 ? void 0 : flags['remove-unreferenced'],
                header,
                induceServers: true,
            });
        }
        catch (err) {
            this.error(err, { exit: 1 });
        }
        // make sure we have a server in the document
        if (!((_a = document.servers) === null || _a === void 0 ? void 0 : _a.some((s) => s.url))) {
            const res = await (0, prompt_1.maybePrompt)({
                name: 'server',
                message: 'please enter a server URL',
                type: 'input',
                default: 'http://localhost:9000',
                // must be a valid URL
                validate: (value) => {
                    try {
                        new URL(value);
                        return true;
                    }
                    catch (err) {
                        return 'must be a valid URL';
                    }
                }
            });
            if (res.server) {
                document.servers = [{ url: res.server }];
            }
            else {
                this.error('no server URL provided, use --server or modify your API spec', { exit: 1 });
            }
        }
        // store document in context
        (0, context_1.setContext)((ctx) => ({ ...ctx, document }));
        const api = new openapi_client_axios_1.default({ definition: document });
        const client = await api.init();
        // don't throw on error statuses
        client.defaults.validateStatus = () => true;
        // select operation
        let operationId = flags.operation;
        if (!operationId) {
            const res = await (0, prompt_1.maybePrompt)([
                {
                    name: 'operation',
                    message: 'select operation',
                    type: 'list',
                    choices: api.getOperations().map((op) => {
                        const { operationId: id, summary, description, method, path } = op;
                        let name = `${method.toUpperCase()} ${path}`;
                        if (summary) {
                            name = `${name} - ${summary}`;
                        }
                        else if (description) {
                            name = `${name} - ${description}`;
                        }
                        if (id) {
                            name = `${name} (${id})`;
                        }
                        return { name, value: id };
                    }),
                },
            ]);
            operationId = res.operation;
        }
        if (!operationId) {
            this.error(`no operationId passed, please specify --operation`, { exit: 1 });
        }
        const operation = api.getOperation(operationId);
        if (!operation) {
            this.error(`operationId ${operationId} not found`, { exit: 1 });
        }
        // fill params
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const params = {};
        for (const param of flags.param || []) {
            const [key, value] = param.split('=');
            params[key.trim()] = value;
        }
        for (const p of operation.parameters || []) {
            const param = p;
            const { name, required, example, schema } = param;
            if (!params[name] && required) {
                const mockedValue = schema ? (0, mock_json_schema_1.mock)(schema) : undefined;
                const value = await (0, prompt_1.maybeSimplePrompt)(name, { required, default: example !== null && example !== void 0 ? example : mockedValue });
                params[name] = value;
            }
        }
        // handle request body
        let data = flags.data;
        if (!data &&
            operation.requestBody &&
            'content' in operation.requestBody &&
            (await (0, prompt_1.maybePrompt)({ type: 'confirm', default: true, name: 'yes', message: 'add request body?' })).yes) {
            const contentType = Object.keys(operation.requestBody.content)[0];
            let defaultValue = (_c = (_b = operation.requestBody.content) === null || _b === void 0 ? void 0 : _b[contentType]) === null || _c === void 0 ? void 0 : _c.example;
            if (!defaultValue && ((_e = (_d = operation.requestBody.content) === null || _d === void 0 ? void 0 : _d[contentType]) === null || _e === void 0 ? void 0 : _e.schema)) {
                defaultValue = JSON.stringify((0, mock_json_schema_1.mock)((_g = (_f = operation.requestBody.content) === null || _f === void 0 ? void 0 : _f[contentType]) === null || _g === void 0 ? void 0 : _g.schema), null, 2);
            }
            if (!defaultValue && contentType === 'application/json') {
                defaultValue = '{}';
            }
            data = (await (0, prompt_1.maybePrompt)({
                type: 'editor',
                message: contentType || '',
                name: 'requestBody',
                default: defaultValue,
                validate: (value) => {
                    if (contentType === 'application/json' && !(0, utils_1.isValidJson)(value)) {
                        return 'invalid json';
                    }
                    return true;
                },
            })).requestBody;
        }
        const securityRequestConfig = await (0, security_1.createSecurityRequestConfig)({
            document,
            operation,
            security: flags.security,
            header: flags.header,
            apikey: flags.apikey,
            token: flags.token,
            username: flags.username,
            password: flags.password,
        });
        debug('securityRequestConfig %o', securityRequestConfig);
        // add cookies
        const cookies = {
            ...securityRequestConfig.cookie,
        };
        const cookieHeader = Object.keys(cookies)
            .map((key) => `${key}=${cookies[key]}`)
            .join('; ');
        // add request headers
        const config = {
            headers: {
                ...securityRequestConfig.header,
                ...(0, utils_1.parseHeaderFlag)(header),
                ...(Boolean(cookieHeader) && { cookie: cookieHeader }),
            },
            params: {
                ...securityRequestConfig.query,
            },
            auth: securityRequestConfig.auth,
        };
        // set content type
        if (!config.headers['Content-Type'] && !config.headers['content-type']) {
            const operationRequestContentType = Object.keys((_j = (_h = operation.requestBody) === null || _h === void 0 ? void 0 : _h['content']) !== null && _j !== void 0 ? _j : {})[0];
            const defaultContentType = (0, utils_1.isValidJson)(data) ? 'application/json' : 'text/plain';
            config.headers['Content-Type'] = operationRequestContentType !== null && operationRequestContentType !== void 0 ? operationRequestContentType : defaultContentType;
        }
        let res;
        try {
            debug('params %o', params);
            debug('data %o', data);
            debug('config %o', config);
            const requestConfig = api.getRequestConfigForOperation(operation, [params, data, config]);
            const request = api.getAxiosConfigForOperation(operation, [params, data, config]);
            debug('requestConfig %o', requestConfig);
            debug('axiosConfig %o', request);
            if (flags.verbose) {
                this.log(chalk.gray('REQUEST META:'));
                this.logJson({ operationId, ...requestConfig });
            }
            else {
                console.warn(`${chalk.green(request.method.toUpperCase())} ${requestConfig.url}`);
            }
            // call operation
            res = await client[operationId](params, data, config);
        }
        catch (err) {
            if (err.response) {
                res = err.response;
            }
            else {
                this.error(err.message, { exit: false });
            }
        }
        // output response fields
        if (flags.include && (res === null || res === void 0 ? void 0 : res.status)) {
            this.log(chalk.gray('RESPONSE META:'));
            this.logJson({
                code: res.status,
                status: res.statusText,
                headers: res.headers,
            });
        }
        else if (res === null || res === void 0 ? void 0 : res.status) {
            if (res.status >= 400) {
                console.warn(`${chalk.bgRed(res.status)} – ${res.statusText}`);
            }
            else {
                console.warn(`${chalk.bgGreen(res.status)} – ${res.statusText}`);
            }
        }
        // output response body
        if (!_.isNil(res === null || res === void 0 ? void 0 : res.data)) {
            try {
                if (flags.verbose || flags.include)
                    this.log(chalk.gray('RESPONSE BODY:'));
                this.logJson(res.data);
            }
            catch (e) {
                this.log(res.data);
            }
        }
        else {
            console.warn(chalk.gray('(empty response)'));
        }
    }
}
exports.Call = Call;
Call.description = 'Call API endpoints';
Call.examples = [
    `$ openapi call -o getPets`,
    `$ openapi call -o getPet -p id=1`,
    `$ openapi call -o createPet -d '{ "name": "Garfield" }'`,
];
Call.flags = {
    ...commonFlags.help(),
    ...commonFlags.parseOpts(),
    ...commonFlags.interactive(),
    ...commonFlags.apiRoot(),
    operation: core_1.Flags.string({ char: 'o', description: 'operationId', helpValue: 'operationId' }),
    param: core_1.Flags.string({ char: 'p', description: 'parameter', helpValue: 'key=value', multiple: true }),
    data: core_1.Flags.string({ char: 'd', description: 'request body' }),
    include: core_1.Flags.boolean({
        char: 'i',
        description: 'include status code and response headers the output',
        default: false,
    }),
    verbose: core_1.Flags.boolean({
        char: 'v',
        description: 'verbose mode',
        default: false,
    }),
    ...commonFlags.securityOpts(),
};
Call.args = {
    definition: core_1.Args.string({
        description: 'input definition file'
    })
};
