"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAvailableSecuritySchemes = exports.applyFlagOverrides = exports.createSecurityRequestConfigForScheme = exports.getActiveSecuritySchemes = exports.createSecurityRequestConfig = void 0;
const debug_1 = require("debug");
const deepMerge = require("deepmerge");
const config_1 = require("./config");
const utils_1 = require("./utils");
const prompt_1 = require("./prompt");
const debug = (0, debug_1.default)('cmd');
const createSecurityRequestConfig = async (params) => {
    let requestSecurityConfig = {
        header: {},
        cookie: {},
        query: {},
    };
    if (Object.keys((0, utils_1.parseHeaderFlag)(params.header)).find((key) => ['authorization', 'x-api-key', 'x-apikey', 'x-api-secret', 'x-secret'].includes(key.toLowerCase()))) {
        // if an authorization header is already set, just return that
        return requestSecurityConfig;
    }
    const securityScheme = await (0, exports.getActiveSecuritySchemes)(params);
    debug('securityScheme %o', securityScheme);
    // read stored security config
    const securityConfig = (0, config_1.getConfigValue)('security', {});
    debug('securityConfig %o', securityConfig);
    for (const schemeName of securityScheme) {
        const stored = securityConfig[schemeName];
        if (stored) {
            // apply stored config
            requestSecurityConfig.header = { ...requestSecurityConfig.header, ...stored.header };
            requestSecurityConfig.cookie = { ...requestSecurityConfig.cookie, ...stored.cookie };
            requestSecurityConfig.query = { ...requestSecurityConfig.query, ...stored.query };
            if (stored.auth) {
                requestSecurityConfig.auth = stored.auth;
            }
        }
        else {
            const schemeDefinition = params.document.components.securitySchemes[schemeName];
            // create new config
            requestSecurityConfig = deepMerge(requestSecurityConfig, await (0, exports.createSecurityRequestConfigForScheme)({
                schemeName,
                schemeDefinition,
                token: params.token,
                apikey: params.apikey,
                username: params.apikey,
                password: params.password,
            }));
        }
    }
    return (0, exports.applyFlagOverrides)({ requestSecurityConfig, ...params });
};
exports.createSecurityRequestConfig = createSecurityRequestConfig;
const getActiveSecuritySchemes = async (params) => {
    var _a, _b;
    // choose security scheme
    const availableSecuritySchemes = (0, exports.getAvailableSecuritySchemes)(params.document, params.operation);
    debug('availableSecuritySchemes %o', availableSecuritySchemes);
    const securitySchemes = new Set();
    (_b = (_a = params.security) === null || _a === void 0 ? void 0 : _a.forEach) === null || _b === void 0 ? void 0 : _b.call(_a, (scheme) => securitySchemes.add(scheme));
    if (!securitySchemes.size && availableSecuritySchemes.length === 1) {
        securitySchemes.add(availableSecuritySchemes[0].name);
    }
    // infer basic scheme if username + password is set
    if (params.username && params.password) {
        const basicScheme = availableSecuritySchemes.find((s) => { var _a, _b; return ((_a = s.schemeDefinition) === null || _a === void 0 ? void 0 : _a.type) === 'http' && ((_b = s.schemeDefinition) === null || _b === void 0 ? void 0 : _b.scheme) === 'basic'; });
        if (basicScheme) {
            securitySchemes.add(basicScheme.name);
        }
    }
    // infer apikey scheme if apikey is set
    if (params.apikey) {
        const apikeyScheme = availableSecuritySchemes.find((s) => { var _a; return ((_a = s.schemeDefinition) === null || _a === void 0 ? void 0 : _a.type) === 'apiKey'; });
        if (apikeyScheme) {
            securitySchemes.add(apikeyScheme.name);
        }
    }
    // infer bearer scheme if token is set
    if (params.token) {
        const bearerScheme = availableSecuritySchemes.find((s) => { var _a, _b; return ((_a = s.schemeDefinition) === null || _a === void 0 ? void 0 : _a.type) === 'http' && ((_b = s.schemeDefinition) === null || _b === void 0 ? void 0 : _b.scheme) === 'bearer'; });
        if (bearerScheme) {
            securitySchemes.add(bearerScheme.name);
        }
    }
    // prompt security scheme choice unless it's obvious
    if (securitySchemes.has('PROMPT') || (securitySchemes.size !== 1 && availableSecuritySchemes.length > 1)) {
        const explicitSecurityScheme = (await (0, prompt_1.maybePrompt)({
            name: 'securityScheme',
            message: 'use security scheme',
            type: 'checkbox',
            choices: availableSecuritySchemes.map((s, idx) => {
                var _a;
                return ({
                    name: [s.name, (_a = s.schemeDefinition) === null || _a === void 0 ? void 0 : _a['description']].filter(Boolean).join(': '),
                    value: s.name,
                    checked: idx === 0,
                });
            }),
        })).securityScheme;
        if (explicitSecurityScheme) {
            return explicitSecurityScheme;
        }
    }
    return [...securitySchemes];
};
exports.getActiveSecuritySchemes = getActiveSecuritySchemes;
const createSecurityRequestConfigForScheme = async (params) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    let requestSecurityConfig = {};
    // prompt for api key
    if (((_a = params.schemeDefinition) === null || _a === void 0 ? void 0 : _a.type) === 'apiKey') {
        const apiKey = (_c = (_b = params.apikey) !== null && _b !== void 0 ? _b : params.token) !== null && _c !== void 0 ? _c : (_d = (await (0, prompt_1.maybePrompt)({
            name: 'key',
            message: `${params.schemeName}: Set API key (${params.schemeDefinition.name})`,
            type: 'input',
        }))) === null || _d === void 0 ? void 0 : _d['key'];
        requestSecurityConfig = {
            [params.schemeDefinition.in]: {
                [params.schemeDefinition.name]: apiKey,
            },
        };
    }
    // prompt for bearer token
    if (((_e = params.schemeDefinition) === null || _e === void 0 ? void 0 : _e.type) === 'http' && ((_f = params.schemeDefinition) === null || _f === void 0 ? void 0 : _f.scheme) === 'bearer') {
        const token = (_g = params.token) !== null && _g !== void 0 ? _g : (_h = (await (0, prompt_1.maybePrompt)({
            name: 'token',
            message: `${params.schemeName}: Set auth token`,
            type: 'input',
        }))) === null || _h === void 0 ? void 0 : _h['token'];
        requestSecurityConfig = {
            header: {
                Authorization: `Bearer ${token}`,
            },
        };
    }
    // prompt for basic auth credentials
    if (((_j = params.schemeDefinition) === null || _j === void 0 ? void 0 : _j.type) === 'http' && ((_k = params.schemeDefinition) === null || _k === void 0 ? void 0 : _k.scheme) === 'basic') {
        const username = (_l = params.username) !== null && _l !== void 0 ? _l : (_m = (await (0, prompt_1.maybePrompt)({
            name: 'username',
            message: `${params.schemeName}: username`,
            type: 'input',
        }))) === null || _m === void 0 ? void 0 : _m['username'];
        const password = (_o = params.password) !== null && _o !== void 0 ? _o : (_p = (await (0, prompt_1.maybePrompt)({
            name: 'password',
            message: `${params.schemeName}: password`,
            type: 'password',
        }))) === null || _p === void 0 ? void 0 : _p['password'];
        requestSecurityConfig = {
            auth: { username, password },
        };
    }
    return (0, exports.applyFlagOverrides)({ requestSecurityConfig, ...params });
};
exports.createSecurityRequestConfigForScheme = createSecurityRequestConfigForScheme;
const applyFlagOverrides = (params) => {
    const { requestSecurityConfig } = params;
    // apply flag overrides
    if (params.username) {
        requestSecurityConfig.auth = { ...requestSecurityConfig.auth, username: params.username };
    }
    if (params.password) {
        requestSecurityConfig.auth = { ...requestSecurityConfig.auth, password: params.password };
    }
    if (params.token) {
        requestSecurityConfig.header = { ...requestSecurityConfig.header, Authorization: `Bearer ${params.token}` };
    }
    return requestSecurityConfig;
};
exports.applyFlagOverrides = applyFlagOverrides;
const getAvailableSecuritySchemes = (document, operation) => {
    var _a, _b, _c;
    if (operation) {
        const availableSecuritySchemeNames = new Set();
        for (const requirementObject of (_a = operation.security) !== null && _a !== void 0 ? _a : []) {
            const securitySchemes = Object.keys(requirementObject);
            securitySchemes === null || securitySchemes === void 0 ? void 0 : securitySchemes.forEach((scheme) => availableSecuritySchemeNames.add(scheme));
        }
        return [...availableSecuritySchemeNames].map((name) => {
            var _a, _b;
            return ({
                name,
                schemeDefinition: (_b = (_a = document.components) === null || _a === void 0 ? void 0 : _a.securitySchemes) === null || _b === void 0 ? void 0 : _b[name],
            });
        });
    }
    else {
        return Object.keys((_c = (_b = document.components) === null || _b === void 0 ? void 0 : _b.securitySchemes) !== null && _c !== void 0 ? _c : {}).map((name) => {
            var _a, _b;
            return ({
                name,
                schemeDefinition: (_b = (_a = document.components) === null || _a === void 0 ? void 0 : _a.securitySchemes) === null || _b === void 0 ? void 0 : _b[name],
            });
        });
    }
};
exports.getAvailableSecuritySchemes = getAvailableSecuritySchemes;
