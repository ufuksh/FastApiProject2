"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const openapi_client_axios_1 = require("openapi-client-axios");
const SwaggerParser = require("@apidevtools/swagger-parser");
const jest_json_schema_1 = require("jest-json-schema");
const config_1 = require("../common/config");
const security_1 = require("../common/security");
const utils_1 = require("../common/utils");
const context_1 = require("../common/context");
const debug_1 = require("debug");
const chalk = require("chalk");
const debug = (0, debug_1.default)('cmd');
expect.extend(jest_json_schema_1.matchers);
const context = (0, context_1.getContext)();
let api;
beforeAll(async () => {
    const definition = await SwaggerParser.dereference(context.document);
    api = new openapi_client_axios_1.default({ definition });
    await api.init();
});
const testConfig = (0, config_1.getConfigValue)('tests');
for (const operationId of Object.keys(testConfig)) {
    describe(operationId, () => {
        for (const testName of Object.keys(testConfig[operationId])) {
            describe(testName, () => {
                const testDefinition = testConfig[operationId][testName];
                let request;
                let response;
                let operation;
                let client;
                let failed = false;
                beforeAll(async () => {
                    operation = api.getOperation(operationId);
                    client = await getClientForTest({ operationId, requestConfig: testDefinition.request.config });
                    request = api.getAxiosConfigForOperation(operation, [testDefinition.request.params, testDefinition.request.data]);
                });
                afterEach(() => {
                    const currentTest = expect.getState();
                    debug('currentTest %o', currentTest);
                    if (!failed && currentTest.assertionCalls > currentTest.numPassingAsserts) {
                        failed = true;
                        verboseLog(`${chalk.bgRed(' FAILED ')} ${chalk.bold(operationId)} › ${testName}\n`);
                        verboseLog(`${chalk.green(request.method.toUpperCase())} ${request.url}`);
                        verboseLog(request);
                        verboseLog(chalk.gray('RESPONSE META:'));
                        verboseLog({
                            code: response.status,
                            status: response.statusText,
                            headers: response.headers,
                        });
                        verboseLog(chalk.gray('RESPONSE BODY:'));
                        verboseLog(response.data || chalk.gray('(empty response)'), '\n');
                    }
                });
                test(`request ${operationId}`, async () => {
                    debug('request %o', request);
                    if (context.flags.verbose) {
                        verboseLog(`${chalk.bold(operationId)} › ${testName}\n`);
                        verboseLog(`${chalk.green(request.method.toUpperCase())} ${request.url}`);
                        verboseLog(request);
                    }
                    response = await client[operationId](testDefinition.request.params, testDefinition.request.data);
                    debug('res %o', { code: response.status, headers: response.headers, data: response.data });
                    if (context.flags.verbose) {
                        verboseLog(chalk.gray('RESPONSE META:'));
                        verboseLog({
                            code: response.status,
                            status: response.statusText,
                            headers: response.headers,
                        });
                        verboseLog(chalk.gray('RESPONSE BODY:'));
                        verboseLog(response.data || chalk.gray('(empty response)'), '\n');
                    }
                });
                if ((['Success2XX', 'default', 'all']).some((check) => testDefinition.checks.includes(check))) {
                    test('should return 2XX response', async () => {
                        expect(`${response.status}`).toMatch(/2\d\d/);
                    });
                }
                if ((['ValidResponseBody', 'default', 'all']).some((check) => testDefinition.checks.includes(check))) {
                    test('response body should match schema', async () => {
                        var _a, _b;
                        const operation = api.getOperation(operationId);
                        const responseObject = operation.responses[response.status] ||
                            operation.responses[`${response.status}`] ||
                            operation.responses.default ||
                            operation.responses[Object.keys(operation.responses)[0]];
                        const schema = (_b = (_a = responseObject === null || responseObject === void 0 ? void 0 : responseObject['content']) === null || _a === void 0 ? void 0 : _a['application/json']) === null || _b === void 0 ? void 0 : _b.schema;
                        expect(response.data).toMatchSchema(schema);
                    });
                }
            });
        }
    });
}
const getClientForTest = async (params) => {
    const client = await api.init();
    const securityRequestConfig = await (0, security_1.createSecurityRequestConfig)({
        document: context.document,
        operation: api.getOperation(params.operationId),
        security: context.flags.security,
        header: context.flags.header,
        apikey: context.flags.apikey,
        token: context.flags.token,
        username: context.flags.username,
        password: context.flags.password,
    });
    debug('securityRequestConfig %o', securityRequestConfig);
    // add cookies
    const cookies = {
        ...securityRequestConfig.cookie,
    };
    const cookieHeader = Object.keys(cookies)
        .map((key) => `${key}=${cookies[key]}`)
        .join('; ');
    // add request headers
    const headers = {
        ...params.requestConfig.headers,
        ...securityRequestConfig.header,
        ...(0, utils_1.parseHeaderFlag)(context.flags.header),
        ...(Boolean(cookieHeader) && { cookie: cookieHeader }),
    };
    if (Object.keys(headers).length) {
        client.defaults.headers.common = headers;
    }
    // add query params
    const queryParams = {
        ...params.requestConfig.params,
        ...securityRequestConfig.query,
    };
    if (Object.keys(params).length) {
        client.defaults.params = queryParams;
    }
    // add basic auth
    const auth = {
        ...params.requestConfig.auth,
        ...securityRequestConfig.auth,
    };
    if (Object.keys(auth).length) {
        client.defaults.auth = auth;
    }
    // don't throw on error statuses
    client.defaults.validateStatus = () => true;
    return client;
};
const verboseLog = (...messages) => {
    const message = messages.map((m) => (typeof m === 'string' ? m : JSON.stringify(m, null, 2))).join(' ');
    process.stderr.write(`${message}\n`);
};
