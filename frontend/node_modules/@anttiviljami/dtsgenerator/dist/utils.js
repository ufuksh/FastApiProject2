"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readConfig = exports.globFiles = exports.buildProxyOptions = exports.readUrl = exports.readStream = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs"));
const url_1 = require("url");
const glob_1 = require("glob");
const http_proxy_agent_1 = require("http-proxy-agent");
const https_proxy_agent_1 = require("https-proxy-agent");
const typescript_1 = require("typescript");
const commandOptions_1 = require("./commandOptions");
function readStream(stream, encoding = 'utf8') {
    stream.setEncoding(encoding);
    return new Promise((resolve, reject) => {
        let data = '';
        stream.on('data', (chunk) => (data += chunk));
        stream.on('end', () => resolve(data));
        stream.on('error', (error) => reject(error));
    });
}
exports.readStream = readStream;
async function readUrl(url) {
    const init = buildProxyOptions(url);
    const res = await fetch(url, init);
    const data = await res.text();
    if (!res.ok) {
        throw new Error(`Error on fetch from url(${url}): ${res.status}, ${data}`);
    }
    return data;
}
exports.readUrl = readUrl;
function noProxy(url) {
    if (process.env.NO_PROXY) {
        for (const domain of process.env.NO_PROXY.split(/[, ]+/)) {
            if (url.hostname.endsWith(domain)) {
                return true;
            }
        }
    }
    return false;
}
function buildProxyOptions(url) {
    const parsedUrl = new url_1.URL(url);
    if (!noProxy(parsedUrl)) {
        if (parsedUrl.protocol === 'http:' && process.env.HTTP_PROXY) {
            return {
                agent: new http_proxy_agent_1.HttpProxyAgent(process.env.HTTP_PROXY),
            };
        }
        else if (parsedUrl.protocol === 'https:' && process.env.HTTPS_PROXY) {
            return {
                agent: new https_proxy_agent_1.HttpsProxyAgent(process.env.HTTPS_PROXY),
            };
        }
    }
    return undefined;
}
exports.buildProxyOptions = buildProxyOptions;
async function globFiles(pattern, options) {
    const result = [];
    for await (const r of (0, glob_1.globIterate)(pattern, options !== null && options !== void 0 ? options : {})) {
        if (typeof r === 'string') {
            result.push(r);
        }
        else {
            result.push(r.fullpath());
        }
    }
    return result;
}
exports.globFiles = globFiles;
function readConfig(options) {
    var _a;
    let pc = {};
    const configFile = (_a = options.configFile) !== null && _a !== void 0 ? _a : commandOptions_1.defaultConfigFile;
    try {
        pc = loadJSON(configFile);
        pc.configFile = configFile;
    }
    catch (err) {
        if (options.configFile != null) {
            console.error('Error to load config file from ' + options.configFile);
        }
    }
    if (pc.input == null) {
        pc.input = {
            files: [],
            urls: [],
            stdin: false,
        };
    }
    if (options.files.length > 0) {
        pc.input.files = options.files;
    }
    else if (pc.input.files == null) {
        pc.input.files = [];
    }
    if (options.urls.length > 0) {
        pc.input.urls = options.urls;
    }
    else if (pc.input.urls == null) {
        pc.input.urls = [];
    }
    if (options.stdin != null) {
        pc.input.stdin = options.stdin;
    }
    else {
        pc.input.stdin =
            pc.input.stdin ||
                (pc.input.files.length === 0 && pc.input.urls.length === 0);
    }
    if (options.out != null) {
        pc.outputFile = options.out;
    }
    if (options.target != null) {
        pc.target = convertToScriptTarget(options.target);
    }
    else if (pc.target != null) {
        pc.target = convertToScriptTarget(pc.target);
    }
    pc.outputAST = !!options.outputAST;
    return pc;
}
exports.readConfig = readConfig;
function loadJSON(file) {
    const content = fs.readFileSync(file, 'utf-8');
    return JSON.parse(content);
}
function convertToScriptTarget(target) {
    switch (target.trim().toLowerCase()) {
        case 'es3':
            return typescript_1.ScriptTarget.ES3;
        case 'es5':
            return typescript_1.ScriptTarget.ES5;
        case 'es2015':
            return typescript_1.ScriptTarget.ES2015;
        case 'es2016':
            return typescript_1.ScriptTarget.ES2016;
        case 'es2017':
            return typescript_1.ScriptTarget.ES2017;
        case 'es2018':
            return typescript_1.ScriptTarget.ES2018;
        case 'es2019':
            return typescript_1.ScriptTarget.ES2019;
        case 'es2020':
            return typescript_1.ScriptTarget.ES2020;
        case 'es2021':
            return typescript_1.ScriptTarget.ES2021;
        case 'es2022':
            return typescript_1.ScriptTarget.ES2022;
        case 'esnext':
            return typescript_1.ScriptTarget.ESNext;
        default:
            return typescript_1.ScriptTarget.Latest;
    }
}
